<<<<<<< HEAD
/**
 * Text layer render parameters.
 */
export type TextLayerRenderParameters = {
    /**
     * - Text content to
     * render (the object is returned by the page's `getTextContent` method).
     */
    textContent?: import("./api").TextContent | undefined;
    /**
     * - Text content stream to
     * render (the stream is returned by the page's `streamTextContent` method).
     */
    textContentStream?: ReadableStream<any> | undefined;
    /**
     * - HTML element that will contain text runs.
     */
    container: HTMLElement;
    /**
     * - The target
     * viewport to properly layout the text runs.
     */
    viewport: import("./display_utils").PageViewport;
    /**
     * - HTML elements that are correspond
     * to the text items of the textContent input. This is output and shall be
     * initially be set to empty array.
     */
    textDivs?: HTMLElement[] | undefined;
    /**
     * - Strings that correspond to
     * the `str` property of the text items of textContent input. This is output
     * and shall be initially be set to empty array.
     */
    textContentItemsStr?: string[] | undefined;
    /**
     * - Delay in milliseconds before rendering of the
     * text runs occurs.
     */
    timeout?: number | undefined;
    /**
     * - Whether to turn on the text
     * selection enhancement.
     */
    enhanceTextSelection?: boolean | undefined;
};
/**
 * @param {TextLayerRenderParameters} renderParameters
 * @returns {TextLayerRenderTask}
 */
export function renderTextLayer(renderParameters: TextLayerRenderParameters): TextLayerRenderTask;
declare class TextLayerRenderTask {
    constructor({ textContent, textContentStream, container, viewport, textDivs, textContentItemsStr, enhanceTextSelection, }: {
        textContent: any;
        textContentStream: any;
        container: any;
        viewport: any;
        textDivs: any;
        textContentItemsStr: any;
        enhanceTextSelection: any;
    });
    _textContent: any;
    _textContentStream: any;
    _container: any;
    _document: any;
    _viewport: any;
    _textDivs: any;
    _textContentItemsStr: any;
    _enhanceTextSelection: boolean;
    _fontInspectorEnabled: boolean;
    _reader: any;
    _layoutTextLastFontSize: any;
    _layoutTextLastFontFamily: any;
    _layoutTextCtx: any;
    _textDivProperties: WeakMap<object, any>;
    _renderingDone: boolean;
    _canceled: boolean;
    _capability: import("../shared/util.js").PromiseCapability;
    _renderTimer: any;
    _bounds: any[];
    /**
     * Promise for textLayer rendering task completion.
     * @type {Promise<void>}
     */
    get promise(): Promise<void>;
    /**
     * Cancel rendering of the textLayer.
     */
    cancel(): void;
    /**
     * @private
     */
    private _processItems;
    /**
     * @private
     */
    private _layoutText;
    /**
     * @private
     */
    private _render;
    /**
     * @param {boolean} [expandDivs]
     */
    expandTextDivs(expandDivs?: boolean | undefined): void;
}
export {};
=======
export type PageViewport = import("./display_utils").PageViewport;
export type TextContent = import("./api").TextContent;
export type TextLayerParameters = {
    /**
     * - Text content to
     * render, i.e. the value returned by the page's `streamTextContent` or
     * `getTextContent` method.
     */
    textContentSource: ReadableStream | TextContent;
    /**
     * - The DOM node that will contain the text
     * runs.
     */
    container: HTMLElement;
    /**
     * - The target viewport to properly layout
     * the text runs.
     */
    viewport: PageViewport;
};
export type TextLayerUpdateParameters = {
    /**
     * - The target viewport to properly layout
     * the text runs.
     */
    viewport: PageViewport;
    /**
     * - Callback invoked before the textLayer is
     * updated in the DOM.
     */
    onBefore?: Function | undefined;
};
export class TextLayer {
    static "__#45@#ascentCache": Map<any, any>;
    static "__#45@#canvasContexts": Map<any, any>;
    static "__#45@#minFontSize": null;
    static "__#45@#pendingTextLayers": Set<any>;
    /**
     * Clean-up global textLayer data.
     * @returns {undefined}
     */
    static cleanup(): undefined;
    static "__#45@#getCtx"(lang?: null): any;
    /**
     * Compute the minimum font size enforced by the browser.
     */
    static "__#45@#ensureMinFontSizeComputed"(): void;
    static "__#45@#getAscent"(fontFamily: any, lang: any): any;
    /**
     * @param {TextLayerParameters} options
     */
    constructor({ textContentSource, container, viewport }: TextLayerParameters);
    /**
     * Render the textLayer.
     * @returns {Promise}
     */
    render(): Promise<any>;
    /**
     * Update a previously rendered textLayer, if necessary.
     * @param {TextLayerUpdateParameters} options
     * @returns {undefined}
     */
    update({ viewport, onBefore }: TextLayerUpdateParameters): undefined;
    /**
     * Cancel rendering of the textLayer.
     * @returns {undefined}
     */
    cancel(): undefined;
    /**
     * @type {Array<HTMLElement>} HTML elements that correspond to the text items
     *   of the textContent input.
     *   This is output and will initially be set to an empty array.
     */
    get textDivs(): HTMLElement[];
    /**
     * @type {Array<string>} Strings that correspond to the `str` property of
     *   the text items of the textContent input.
     *   This is output and will initially be set to an empty array
     */
    get textContentItemsStr(): string[];
    #private;
}
>>>>>>> e497afe6fae2d9331574ec0bf69764c3480ace51
