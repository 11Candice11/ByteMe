<<<<<<< HEAD
=======
export type PDFDocumentProxy = import("../src/display/api").PDFDocumentProxy;
export type EventBus = import("./event_utils").EventBus;
export type IPDFLinkService = import("./interfaces").IPDFLinkService;
>>>>>>> e497afe6fae2d9331574ec0bf69764c3480ace51
export type PDFFindControllerOptions = {
    /**
     * - The navigation/linking service.
     */
<<<<<<< HEAD
    linkService: any;
    /**
     * - The application event bus.
     */
    eventBus: any;
};
export namespace FindState {
    const FOUND: number;
    const NOT_FOUND: number;
    const WRAPPED: number;
    const PENDING: number;
=======
    linkService: IPDFLinkService;
    /**
     * - The application event bus.
     */
    eventBus: EventBus;
    /**
     * - True if the matches
     * count must be updated on progress or only when the last page is reached.
     * The default value is `true`.
     */
    updateMatchesCountOnProgress?: boolean | undefined;
};
export namespace FindState {
    let FOUND: number;
    let NOT_FOUND: number;
    let WRAPPED: number;
    let PENDING: number;
>>>>>>> e497afe6fae2d9331574ec0bf69764c3480ace51
}
/**
 * @typedef {Object} PDFFindControllerOptions
 * @property {IPDFLinkService} linkService - The navigation/linking service.
 * @property {EventBus} eventBus - The application event bus.
<<<<<<< HEAD
=======
 * @property {boolean} [updateMatchesCountOnProgress] - True if the matches
 *   count must be updated on progress or only when the last page is reached.
 *   The default value is `true`.
>>>>>>> e497afe6fae2d9331574ec0bf69764c3480ace51
 */
/**
 * Provides search functionality to find a given string in a PDF document.
 */
export class PDFFindController {
    /**
     * @param {PDFFindControllerOptions} options
     */
<<<<<<< HEAD
    constructor({ linkService, eventBus }: PDFFindControllerOptions);
    _linkService: any;
    _eventBus: any;
=======
    constructor({ linkService, eventBus, updateMatchesCountOnProgress }: PDFFindControllerOptions);
    _linkService: import("./interfaces").IPDFLinkService;
    _eventBus: import("./event_utils").EventBus;
    /**
     * Callback used to check if a `pageNumber` is currently visible.
     * @type {function}
     */
    onIsPageVisible: Function;
>>>>>>> e497afe6fae2d9331574ec0bf69764c3480ace51
    get highlightMatches(): boolean | undefined;
    get pageMatches(): any[] | undefined;
    get pageMatchesLength(): any[] | undefined;
    get selected(): {
        pageIdx: number;
        matchIdx: number;
    } | undefined;
<<<<<<< HEAD
    get state(): any;
=======
    get state(): null;
>>>>>>> e497afe6fae2d9331574ec0bf69764c3480ace51
    /**
     * Set a reference to the PDF document in order to search it.
     * Note that searching is not possible if this method is not called.
     *
     * @param {PDFDocumentProxy} pdfDocument - The PDF document to search.
     */
<<<<<<< HEAD
    setDocument(pdfDocument: any): void;
    _pdfDocument: any;
    executeCommand(cmd: any, state: any): void;
    _dirtyMatch: boolean | undefined;
    _state: any;
    _findTimeout: any;
    _highlightMatches: boolean | undefined;
    scrollMatchIntoView({ element, selectedLeft, pageIndex, matchIndex, }: {
        element?: any;
        selectedLeft?: number | undefined;
        pageIndex?: number | undefined;
        matchIndex?: number | undefined;
    }): void;
    _scrollMatches: boolean | undefined;
    _reset(): void;
=======
    setDocument(pdfDocument: PDFDocumentProxy): void;
    _pdfDocument: import("../src/display/api").PDFDocumentProxy | null | undefined;
    _dirtyMatch: boolean | undefined;
    _findTimeout: any;
    _highlightMatches: boolean | undefined;
    /**
     * @typedef {Object} PDFFindControllerScrollMatchIntoViewParams
     * @property {HTMLElement} element
     * @property {number} selectedLeft
     * @property {number} pageIndex
     * @property {number} matchIndex
     */
    /**
     * Scroll the current match into view.
     * @param {PDFFindControllerScrollMatchIntoViewParams}
     */
    scrollMatchIntoView({ element, selectedLeft, pageIndex, matchIndex, }: {
        element: HTMLElement;
        selectedLeft: number;
        pageIndex: number;
        matchIndex: number;
    }): void;
    _scrollMatches: boolean | undefined;
>>>>>>> e497afe6fae2d9331574ec0bf69764c3480ace51
    _pageMatches: any[] | undefined;
    _pageMatchesLength: any[] | undefined;
    _selected: {
        pageIdx: number;
        matchIdx: number;
    } | undefined;
    _offset: {
        pageIdx: null;
        matchIdx: null;
        wrapped: boolean;
    } | undefined;
    _extractTextPromises: any[] | undefined;
    _pageContents: any[] | undefined;
    _pageDiffs: any[] | undefined;
<<<<<<< HEAD
    _matchesCountTotal: number | undefined;
    _pagesToSearch: any;
    _pendingFindMatches: Set<any> | undefined;
    _resumePageIdx: any;
    _firstPageCapability: any;
    /**
     * @type {string} The (current) normalized search query.
     */
    get _query(): string;
    _rawQuery: any;
    _shouldDirtyMatch(cmd: any, state: any): boolean;
    /**
     * Helper for multi-term search that fills the `matchesWithLength` array
     * and handles cases where one search term includes another search term (for
     * example, "tamed tame" or "this is"). It looks for intersecting terms in
     * the `matches` and keeps elements with a longer match length.
     */
    _prepareMatches(matchesWithLength: any, matches: any, matchesLength: any): void;
    /**
     * Determine if the search query constitutes a "whole word", by comparing the
     * first/last character type with the preceding/following character type.
     */
    _isEntireWord(content: any, startIdx: any, length: any): boolean;
    _calculatePhraseMatch(query: any, pageIndex: any, pageContent: any, pageDiffs: any, entireWord: any): void;
    _calculateWordMatch(query: any, pageIndex: any, pageContent: any, pageDiffs: any, entireWord: any): void;
    _calculateMatch(pageIndex: any): void;
    _extractText(): void;
    _updatePage(index: any): void;
    _updateAllPages(): void;
    _nextMatch(): void;
    _matchesReady(matches: any): boolean;
    _nextPageMatch(): void;
    _advanceOffsetPage(previous: any): void;
    _updateMatch(found?: boolean): void;
    _onFindBarClose(evt: any): void;
    _requestMatchesCount(): {
        current: number;
        total: number | undefined;
    };
    _updateUIResultsCount(): void;
    _updateUIState(state: any, previous: any): void;
=======
    _hasDiacritics: any[] | undefined;
    _matchesCountTotal: number | undefined;
    _pagesToSearch: number | null | undefined;
    _pendingFindMatches: Set<any> | undefined;
    _resumePageIdx: any;
    _firstPageCapability: any;
    _rawQuery: any;
    /**
     * @typedef {Object} FindMatch
     * @property {number} index - The start of the matched text in the page's
     *   string contents.
     * @property {number} length - The length of the matched text.
     */
    /**
     * @param {string | string[]} query - The search query.
     * @param {string} pageContent - The text content of the page to search in.
     * @param {number} pageIndex - The index of the page that is being processed.
     * @returns {FindMatch[] | undefined} An array of matches in the provided
     *   page.
     */
    match(query: string | string[], pageContent: string, pageIndex: number): {
        /**
         * - The start of the matched text in the page's
         * string contents.
         */
        index: number;
        /**
         * - The length of the matched text.
         */
        length: number;
    }[] | undefined;
    #private;
>>>>>>> e497afe6fae2d9331574ec0bf69764c3480ace51
}
